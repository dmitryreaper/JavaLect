#+STARTUP: showall

* Введение
JDK(java development kit) - бесплатный набор инструментов от компании Oracle упрощающих
разработку приложений Java.
	К числу иструметов входят комрилятор(javac), архиватор(jar), и генератор документации для
построения документации в формате HTML на основе кода Java (javadoc)

Команда package она сообщает компилятору что файл Java который вы создли является частью пакета
(имя пакета)

Пакет - это просто набор взаимосвязанных классов и интерфейсов. Вставляя строку package (название);
в начало своего файла, вы тем самым приказываете компилятору влючить этот файл в пакет (название)
Компилятор создает папку с именем (название) и сохраняет в этой папке файлы , принадлежащие этому
пакету, хранятся в одной папке.

* Типы данных

Существует восемь заранее определенных базовых типов данных. Они нызываются примитивными типами данных

Первые четыре типа данных предназначены для хранения целых чисел

*byte* - тип данных byte используется для хранения целых чисел от -128 до 127. Он использует
один бай памяти для хранения данных (размер типа данных, также называемый его шириной).

*short* - тип данных short использует 2 байта памяти и может использоваться для хранения значений
в диапазоне от -32768 до 32767

*int* - тип данных int использует 4 байта памяти и может использоваться для хранения значений в диапазоне
от -2^31 до 2^31

*long* — тип данных long использует 8 байтов памяти и может использоваться для хранения значений в диапазоне
от –263 до 263–1.

*float* — тип данных float использует 4 байта памяти и может использоваться для хранения значений в диапазоне
приблизительно от –3.40282347 × 1038 до 3.40282347 × 1038.

*double* — тип данных double использует 8 байт памяти и может использоваться для хранения значений в диапа-
зоне приблизительно от –1.79769313486231570 × 10308 до 1.79769313486231570 × 10308 с точностью представления
приблизительно до 15 цифр.

Когда вы определяете число с плавающей точкой в Java, по умолчанию оно автоматически считается относящимся
к типу double, а не float.

Кроме шести типов данных, упоминавшихся выше, в Java существуют еще два примитивных типа данных:

*char* — тип данных для представления отдельных сим-
волов Юникода: A, %, @, p и т. д. Использует 2 байта
памяти;

*boolean* — специальный тип данных, который может использоваться для хранения только двух значений:
true и false. Чаще всего тип boolean используется в управляющих командах.

* Преобразование типов
#+begin_src java
  short age = 10;
  double my Double = age; // такое преобразование называется расширяющим примитивным преобразованием

  int x = (int) 20.9; // Такое преобразование называется сужающим примитивным преобразованием.
#+end_src

Сужающее преобразование небезопасно, и его следует избегать, если только это возможно. Дело в том, что сужающее
преобразование может привести к потере данных. При преобразовании значения 20.9 в int будет получен
результат 20, а не 21. Дробная часть пропадает после преобразования.

* Тип String

#+begin_src java
  String message = "Hello World"; // объявление и инициализация
  String myName = "Hello World, " + "my name is Jamie"; // Для соеденения двух и более строк используется конкатенации (+)

#+end_src

Значение String является объектом класса String.

*Методы String:*

Метод length() сообщает общее количество символов, содержащихся в строке.
#+begin_src java
  // для получения длины строки
  int myLength = "Hello World".length(); // При использовании метода необходимо использовать оператор «точка» (.)
#+end_src

Метод toUpperCase() используется для преобразования строки к верхнему регистру. Метод toLowerCase() используется
для преобразования строки к нижнему регистру.
String uCase = "Hello World".toUpperCase();

Метод substring() предназначен для выделения подстроки из более длинной строки.
методу substring() для работы необходим один аргумент.

#+begin_src java
  String firstSubstring = "Hello World".substring(6);
#+end_src
Число 6 в круглых скобках называется аргументом. Этот аргумент сообщает компилятору, с какой позиции следует
начинать извлечение подстроки. По сути вы даете команду компилятору выделить подстроку от индекса 6 (т. е. позиции 6)
и до конца строки.

У метода substring() также существует другая разновидность, которая позволяет выделить подстроку от одного
индекса до другого. Если вам потребуется выделить подстроку от позиции 1 до позиции 7, это можно сделать так:
#+begin_src java
  String message = "Hello World";
  String secondSubstring = message.substring(1, 8);
#+end_src

Метод charAt() возвращает один символ, находящийся в заданной позиции. Полученный символ может быть присвоен
переменной типа char.
#+begin_src java
  char myChar = "Hello World".charAt(1); // извлекает символ с индексом 1 и присваивает его myChar
#+end_src

equals() — метод equals() используется для проверки равенства двух строк. Он возвращает true, если строки
равны, и false в противном случае.
#+begin_src java
  boolean equalsOrNot = "This is Jamie".equals("This is Jamie");
  boolean equalsOrNot2 = "This is Jamie".equals("Hello World");
#+end_src
переменная equalsOrNot будет равна true, тогда как переменная equalsOrNot2 будет равна false.

split() — метод разбивает строку на подстроки по разделителям, определяемым пользователем. После разбиения строки
метод split() возвращает массив полученных подстрок. Массив представляет собой коллекцию взаимосвязанных
элементов. 
#+begin_src java
  String names = "Peter, John, Andy, David";
  String[] splitNames = names.split(", ");
#+end_src

* Массивы
#+begin_src java
  class Program{
	  public static void main(String[] argc){
		  int[] array; // Объявление массива
		  array = new int[] {21,22,23,24,25}; //Создает массив и присваивает его array
		  int[] userAge = new int[5]; // Объявление и инициализация массива. Java автоматически создает массив,
		  // инициализирует элеметы значением по умолчанию и присваивает его Userage. Будет содержать {0,0,0,0,0}
		  userAge[0] = 31; // Обращение по индексу
		  userAge[2] = userage[2] + 20;
	  }
  }
#+end_src

** Методы массивов
Массивы как и строки содержат набор готовых методов.

Методы которые рассматриваются, находятся в классе java.util.Arrays. Чтобы пользоваться ими нужно добавить
в свою программу команду:

import java.util.Arrays;

Команда import должна распологатся в программе после команды package, но до объявления класса.
Пример:
#+begin_src java
  package helloworld;
  import java.util.Arrays;
  public class HelloWorld {
	  // Code
  }
#+end_src

Часто используемые методы массивов:

*equals()* — метод проверяет равенство двух массивов. Если массивы равны, то метод возвращает true, а если
нет — false. Два массива считаются равными, если они содержат одинаковое количество элементов, а эти элементы
равны и следуют в одинаковом порядке.
#+begin_src java
  package helloworld;
  import java.util.Arrays;
  
  public class HelloWorld {
	  int[] arr1 = {0,2,4,6,8,10};
	  int[] arr2 = {0,2,4,6,8,10};
	  int[] arr3 = {10,8,6,4,2,0};
	  boolean result1 = Arrays.equals(arr1, arr2); // равны result1 = true
	  boolean result2 = Arrays.equals(arr1, arr3); // не равны result2 = false
  }
#+end_src

! Перед именем метода добавлено слово Arrays. Дело в том что все методы класса Arrays являются статическими.
Чтобы вызвать статический метод, следует указать перед ним имя класса.

*copyOfRange()* — метод копирует содержимое одного массива в другой массив. При вызове он получает три аргумента.
#+begin_src java
	  package helloworld;
	  import java.util.Arrays;

	  public class HelloWorld {
		  int [] source = {12, 1, 5, -2, 16, 14, 18, 20, 25}; // Имеется следующий массив
		  //Содержимое source можно скопировать в новый массив dest следующей командой:
		  int[] dest = Arrays.copyOfRange(source, 3, 7);
	  }
#+end_src

Первый аргумент (source) определяет массив с копируемыми значениями. Второй и третий аргументы сообщают
компилятору, на каком индексе должно начинаться и останавливаться копирование соответственно. Иначе говоря,
в нашем примере копируются элементы от индекса 3 до индекса 6 включительно (т. е. элемент с индексом 7
не копируется). После копирования элементов метод copyOfRange() возвращает массив со скопированными числами. Этот
массив присваивается dest.

*toString()* — метод возвращает объект String , представляющий элементы массива. Такое преобразование упрощает
вывод содержимого массива. Допустим, имеется массив.
#+begin_src java
  package helloworld;
  import java.util.Arrays;

  public class HelloWorld {
	  int[] numbers = {1, 2, 3, 4, 5};
	  System.out.println(Arrays.toString(numbers)); // Для вывода содержимого numbers
  }
#+end_src

*sort()* — метод предназначен для сортировки массивов. В аргументе ему передается массив.
#+begin_src java
  package helloworld;
  import java.util.Arrays;

  public class HelloWorld {
	  int [] numbers2 = {12, 1, 5, -2, 16, 14}; // Имеется массив
	  //Чтобы его отсортировать нужно выполнить следующее
	  Arrays.sort(numbers2); // Массив будет отсортирован по возрастанию
	  System.out.println(Arrays.toString(numbers2)); //Для вывода отсортированного массива
  }
#+end_src
Метод sort() не возващает новый массив. Он просто изменяет массив, переданный при вызове.

*binarySearch()* — метод ищет конкретное значение в отсортированном массиве. Чтобы использовать этот метод,
необходимо предварительно отсортировать массив. Для сортировки можно воспользоваться методом sort(), описанным выше.
#+begin_src java
  package helloworld;
  import java.util.Arrays;

  public class HelloWorld {
	  int[] myInt = {21, 23, 34, 45, 56, 78, 99}; // Имеется массив
	  // Чтобы определить присутствует ли значение 78 в массиве, нужно выполнить
	  int foundIndex = Arrays.binarySearch(myInt, 78);
	  //Значение foundindex будет равно 5. Оно показывает что число 78 находится в элементе массива с индексом 5

	  int foundIndex2 = Arrays.binarySearch(myInt, 39);
	  //Знак «-» просто означает, что значение 39 не найдено.
  }
#+end_src

** Определение длины массива
Длина массива сообщает количество элементов в массиве. Ранее при обсуждении строк мы упоминали, что для определения
длины строк можно использовать метод length().

Для получения длины массива не нужно добавлять круглые скобки после слова length.
#+begin_src java
  int [] userAge = {21, 22, 26, 32, 40};
  int size = userAge.length; // size = 5 так как массив содержит 5 чисел
#+end_src

* Примитивные типы и ссылочные типы

